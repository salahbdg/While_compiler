# Semantic Checker Documentation



## Overview

The Semantic Checker is a tool designed to analyze programs written according to the AST grammar specification. It performs comprehensive semantic analysis to ensure program correctness beyond syntactic validation. The checker processes Abstract Syntax Trees (ASTs) generated by ANTLR3 and validates various semantic rules and constraints.

## Architecture

### Core Components

1. **SemanticChecker**
   - Main class handling the semantic analysis process
   - Entry point for all semantic validations
   - Coordinates between other components

2. **SymbolTable**
   - Manages variable scoping
   - Tracks variable declarations
   - Implements nested scope handling

3. **FunctionTable**
   - Stores function declarations
   - Manages function signatures
   - Tracks function dependencies

4. **ErrorCollector**
   - Collects and manages semantic errors
   - Provides error reporting functionality
   - Maintains error location information

## Workflow

The semantic checker follows a multi-pass analysis approach:

### 1. Initial Validation
```
AST Input → Structure Validation → Basic Checks
```

### 2. Analysis Phases
1. **First Pass**
   - Collect function declarations
   - Validate function names
   - Check for duplicate functions
   - Verify main function existence

2. **Second Pass**
   - Build function call graph
   - Detect circular dependencies
   - Analyze function reachability

3. **Third Pass**
   - Check function bodies
   - Validate variable usage
   - Verify control flow
   - Check expressions

4. **Final Pass**
   - Identify unreachable code
   - Verify completeness
   - Check for undefined behaviors

## Error Detection

The checker detects the following categories of errors:

### 1. Program Structure Errors
- Missing main function
- Invalid function declarations
- Duplicate function definitions
- Improper program structure

### 2. Function-Related Errors
- Invalid function signatures
- Parameter count mismatches
- Undefined function calls
- Circular dependencies
- Unreachable functions

### 3. Variable Errors
- Undefined variables
- Duplicate variable declarations
- Scope violations
- Unused variables

### 4. Type and Expression Errors
- Invalid list operations
- Type mismatches
- Invalid expressions
- Improper function calls

### 5. Control Flow Errors
- Invalid loop conditions
- Unreachable code
- Invalid control structures

## Class Structure

### SemanticChecker
```java
public class SemanticChecker {
    // Core components
    private SymbolTable symbolTable;
    private ErrorCollector errorCollector;
    private FunctionTable functionTable;

    // Main entry point
    public boolean check(CommonTree tree)

    // Primary analysis methods
    private void checkProgram(CommonTree tree)
    private void checkFunction(CommonTree functionNode)
    private void checkCommands(CommonTree commandsNode)
}
```

### Error Handling
```java
public class ErrorCollector {
    private List<SemanticError> errors;
    
    public void addError(String message, int line)
    public List<SemanticError> getErrors()
}
```

## Semantic Rules

### Function Rules
1. Program must have a main function
2. Main function must have no input parameters
3. Main function must have at least one output parameter
4. Function names must be unique
5. All functions must be reachable from main

### Variable Rules
1. Variables must be declared before use
2. Variables must be defined within proper scope
3. Output variables must be assigned before function return
4. No duplicate variable names in same scope

### Control Flow Rules
1. Loop conditions must be valid expressions
2. For/foreach loops must operate on list types
3. If conditions must be valid expressions
4. All code must be reachable

## Usage Guide

### Basic Usage
```java
SemanticChecker checker = new SemanticChecker();
boolean isValid = checker.check(astRoot);

if (!isValid) {
    List<SemanticError> errors = checker.getErrors();
    // Handle errors
}
```

### Error Handling
```java
List<SemanticError> errors = checker.getErrors();
for (SemanticError error : errors) {
    System.err.println("Line " + error.getLine() + ": " + error.getMessage());
}
```

## Error Messages

Common error messages and their meanings:

1. Program Structure
```
"No main function defined"
- Program lacks required main function

"Function [name] is already defined"
- Duplicate function definition

"Invalid top-level declaration"
- Only functions allowed at top level
```

2. Function Errors
```
"Undefined function: [name]"
- Function call to non-existent function

"Function [name] expects [X] arguments but got [Y]"
- Function call with wrong number of arguments

"Circular dependency detected"
- Recursive function calls that form a cycle
```

3. Variable Errors
```
"Undefined variable: [name]"
- Use of variable before declaration

"Duplicate variable name: [name]"
- Variable name already used in current scope

"Output variable [name] is not defined"
- Function trying to output undefined variable
```

4. Type Errors
```
"Head/Tail operation requires a list expression"
- Invalid use of list operations

"For loop range must be a list expression"
- Invalid loop range expression

"Foreach loop collection must be a list expression"
- Invalid foreach collection type
```

### Integration with ANTLR

The semantic checker expects an AST generated by ANTLR3 following the specified grammar. The AST should be passed as a CommonTree object to the checker's main entry point.

Example integration:
```java
// Assume parser is your ANTLR parser
CommonTree ast = (CommonTree) parser.program().getTree();
SemanticChecker checker = new SemanticChecker();
boolean isValid = checker.check(ast);
```

### Error Reporting

Errors are reported with:
- Line number
- Error message
- Error category
- Context information where applicable

Example error report:
```
Line 10: Undefined variable 'x' in function 'calculate'
Line 15: Function 'process' expects 2 arguments but got 3
Line 20: Circular dependency detected involving function: 'recursive_func'
```

## Best Practices

1. Always check the return value of the semantic checker
2. Handle all reported errors appropriately
3. Maintain clean scope boundaries
4. Ensure all variables are properly declared
5. Verify function calls match declarations

## Limitations

1. No type inference system
2. Limited recursion detection
3. Basic list operation validation
4. No optimization suggestions
5. No data flow analysis

## Future Improvements

1. Add type inference system
2. Implement data flow analysis
3. Add optimization suggestions
4. Enhance error recovery
5. Add warning levels
6. Implement more sophisticated recursive analysis